
<html>

<head>
<title>Project 1a: Sorting with Variable-Sized Records</title> 
</head> 

<body text=black bgcolor=white link=#00aacc vlink=#00aacc alink=orange>

<center><table><tr><td width=500pt>

<center>
<font color=#00aacc>
<h1>Project 1a: Sorting with Variable-Sized Records</h1> 
</font> 
</center> 

<p>You will write a simple sorting program. This program should be invoked as
follows:
<blockquote><pre>
shell% ./varsort -i inputfile -o outputfile 
</pre> </blockquote> </p> 

<p>The above line means the users typed in the name of the sorting program
<code>./varsort</code> and gave it two inputs: 
<ul>
<li> an input file to sort called <code> inputfile</code> 
<li> an output file called <code>outputfile</code> to put the sorted
  results 
</ul>
</p> 

<p>Input files are generated by a program we give you called
<a href=genvar.c>genvar.c</a> .</p> 

<p>After running <code>genvar</code>, you will have a file that needs to be
sorted.  Note that this file is filled with <b>binary data</b> and not ASCII data, so if you try use <code>cat</code> or <code>more</code> to look at the file, you will see what looks like just a bunch of garbage characters.

<p>The file begins with a <b>header</b>.  This header is a single integer, <b>R</b> containing the number of records in this file.

<p> After the header, the file contains a <R> variable-sized
records. Each record can be a different size and each is structured as follows:
<ul>
<li> <b>Key:</b> the first four bytes of each record are an unsigned integer key.  The key determines the order the records should be sorted in.
<li> <b>Data size:</b> the second four bytes are an unsigned integer indicating the size
  N (in integers, or words) of the following data that is associated with this key
<li> <b>Data:</b> N integers (or words) of Data for this key.  This
data should always stay associated with this key.
</ul>

For example, one record could look like the following, where each letter
  represents one byte, and <8> represents the integer (four bytes) holding the
  number of integers (each of which is 4 bytes) for the associated data:</p> 

<p>
<pre>
kkkk<8>DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
</pre> 
</p> 

Again, the key is four bytes and this data is 8 integers, or 8 *
sizeof(integer) = 8 * 4 = 32 bytes.

<p>
Note that different records can have keys with different amounts of
associated data.

<p>Your goal: to build a sorting program called <code>varsort</code>
that takes in one of these generated files and sorts it in ascending
order (from lowest to highest) based on the 4-byte key (the remainder
of the record should of course be kept with the same key). The header
and the sorted keys and their associated records are written to the
specified output file.</p>

<h2>Some Details</h2> 

<p>Using <code>genvar</code> is easy. First you compile it as follows:
<blockquote><pre>
shell% gcc -o genvar genvar.c -Wall -Werror
</pre> </blockquote> </p> 

<p>Note: you will also need the header file <a href=sort.h>sort.h</a> to compile
this program.</p> 

<p>Then you run it:
<blockquote><pre>
shell% ./genvar -s 0 -n 100 -m 32 -o /tmp/outfile
</pre> </blockquote> </p> 

<p>There are four flags to <code>genvar</code> . The <code>-s</code> flag specifies a
random number seed; this allows you to generate different files to test your
sort on. The <code>-n flag</code> determines how many records to write to the output
file. The <code>-m flag</code> designates the maximum amount of data
  that is associated with a key, measured in units of integers (note
  that records can have LESS than this amount of data).  Finally, the <code>-o</code> flag determines the
output file, which will be the input file for your sort.</p> 

<p>The format of the file generated by the <code>genvar.c</code>
program is very simple: it is in binary form, and consists of the
header information and those variable-sized records as described
above. 

<p>Another useful tool is <a href=dumpvar.c>dumpvar.c</a> . This program can be used to
dump the contents of a file generated by <code>genvar</code> or by your sorting
program. </p> 

<p>For example, if run as follows:
<blockquote><pre>
shell% ./dumpvar -i /tmp/file
</ore></blockquote>

then <code>dumpvar</code> will take the binary data in <code>/tmp/file</code> and display the keys and records in a human-readable ASCII format.


<p>When you create files to sort, we strongly recommend that you place
those files in <code>/tmp</code> rather than in your home directory or
course project work space.  Files in <code>/tmp</code> are stored in
the local file system for a particular machine instead of in the AFS
distributed file system space; therefore, with <code>/tmp</code> you
won't run into quota problems and accessing the local files should be
relatively quick.  Of course, the files you create
in <code>/tmp</code> on one machine will not exist on a different
machine.

<p>You will probably want to the look at the source code for both of
  these utilities to see how to read and write to files; in
  particular, they could be useful for seeing how to understand the
  variable-sized record format.

<p> A common header file <a href=sort.h>sort.h</a> has the detailed
description.  There are three different versions of the record that
you might find useful in different circumstances: 
<ul>
<li> <code>rec_nodata_t</code>: a structure that contains no data
<li> <code>rec_data_t</code> : a structure that contains the maximum amount of
data
<li> <code>rec_dataptr_t</code> : a structure that contains a pointer to the data (allocated elsewhere)</p>
</ul>

<p>Note that you may NOT simply allocate an array of <code>rec_data_t</code>
  structures for this project because the <code>rec_data_t</code> structure assumes the
  worst-case size for the amount of data that can be associated with a
  key (<code>MAX_DATA_INTS</code>).  You must <b>dynamically</b> allocate only the amount of memory
  needed for each record, which might be significantly smaller than
  the maximum amount.  You will want to use <code>malloc</code> to
  allocate the correct amount of data for each record and set
  the <code>data_ptr</code> field in the <code>rec_dataptr_t</code>
  structure to point to this data on the heap.

<h2>Hints</h2> 

<p>In your sorting program, you should just use <code>open()</code> , <code>read()</code> ,
<code>write()</code> , and <code>close()</code> to access files. See the code in <code>
genvar</code> or <code>dumpvar</code> for examples.  Make sure you print an appropriate error message and exit correctly if an error occurs!</p> 

<p>To sort the data, use any sort that you'd like to use. An easy way
to go is to use the library routine <code>qsort()</code>
. The <code>qsort()</code> routine is a bit tricky to use, so you will
definitely want to look at the document for it.  Typing <code>man
qsort</code> at the command line will give you a lot of information on
how to use the library sorting routine.  In particular, you will want to study the example code that demonstrates how to use <code>qsort</code> and how to specify a comparison function.  Note that the comparison function takes as arguments <b>pointers</b> to the objects being compared.  </p>

<p>The routine <code>malloc()</code> is useful for memory
allocation. Make sure to print an error message and exit cleanly if
malloc fails!</p>

<p>Remember to write out the header (i.e., the number of records) for
your sorted output.  <code>genvar</code> won't work without it.

<p> For efficiency, you might not want to call <code>malloc</code>
  separately for the data in each record.  Maybe you can allocate the
  memory for all the data at once.  If you want to figure out how big
  the input file is before reading it in, use the <code>stat()</code>
  or <code>fstat()</code> calls.  After you've read the header and
  know the number of records in the file, you can calculate how much
  space is needed for the fixed sized portion of the records (keys,
  data_ints, and pointers) versus for the variable-sized data.  After
  you've allocated enough memory, you can then carefully set up the
  pointer in the <code>rec_datptr_t</code> structure so that record
  refers to the correct data.  Note that when you swap two records
  during your sort, you will now be swapping the corresponding
  pointers instead of all the data associated with the records --
  which should be much faster for large records.

<p>To exit, call <code>exit()</code> with a single argument. This
argument to exit() is then available to the user to see if the program
returned an error (i.e., return 1 by calling <code>exit(1)</code> ) or
exited cleanly (i.e., returned 0 by calling <code>exit(0)</code>
).</p>

<p>If you don't know how to use these functions, use the man pages!</p> 

<p>To do some preliminary testing of your implementation
of <code>varsort</code>, test to see if you generate the file
<a href=sample-out>sample-out</a> given the input <a href=sample-in>sample-in</a>.

<p>
In addition to testing for correct program behavior, we will also be
giving points for good programming style and for careful memory
management.
<p>
As programmers, we often won't be writing all our own code from
scratch, and instead will be making contributions inside of an already
existing project which other people are also contributing to. In these
situations, other programmers will often need to be able to read and
understand the code you've written. Because of this, many companies
will require its programmers to adhere to a style guideline, so that
the task of reading and understanding another person's code is made
easier.
<p>

For grading on style, we will mostly stick to the style guidelines
which Google uses for C++ (more info can be found
<a href=https://google.github.io/styleguide/cppguide.html>here</a>)
with a few differences specific to C.  These differences are in the
config file in <code>~cs537-1/ta/lint/CPPLINT.cfg</code>. To grade
this, we will be running a kind of program called a "lint program", or
a "linter", which just does basic style checking. The linter we will
use can be found here:
<p>
<blockquote><pre>
~cs537-1/ta/lint/cpplint.py
</pre> </blockquote> </p> 
<p>
We will be running it with the following options:
<p>
<blockquote><pre>
cpplint.py --extensions=c,h varsort.c
</pre> </blockquote> </p> 

<p>
Another important skill to develop in C programming is good memory management.  This means freeing any heap space you've allocated when you're done using it!  Since memory is a limited resource, we will want to free memory when we're done with it so that it can be reused. To check that your code doesn't contain memory leaks, we will be using a tool known as valgrind. It's a simple tool which moniters every call to malloc (and other memory allocation functions) and free to make sure that all memory allocated to our program is subsequently released when we are done with it. Our tests will be running valgrind on your code in the following way:
<blockquote><pre>
valgrind --show-reachable=yes ./varsort -i infile -o outfile
</pre> </blockquote> </p> 
<h2>Assumptions and Errors</h2> 

<p>
<p><b>32-bit integer range.</b> You may assume that the keys are unsigned 32-bit
integers.</p> 
<p><b>Record size.</b> You may assume that there are no more than
  USHRT_MAX data items in each record.  However, most records may have
  many fewer data items than the max, so don't allocate this much
  memory for every record!
<p><b>File length:</b> May be pretty long! However, there is no need to
implement a fancy two-pass sort or anything like that.</p> 
<p><b>Invalid files:</b> If the user specifies an input or output file that you
cannot open (for whatever reason), the sort should EXACTLY print: <code>Error:
Cannot open file foo</code> (with no extra spaces, and assuming the file was named <code>foo</code> )
and then exit.</p> 
<p><b>Too few or many arguments passed to program:</b> If the user runs varsort
without enough arguments, or in some other way passes incorrect flags and such to
varsort, print <code>Usage: varsort -i inputfile -o outputfile </code> and exit.</p> 
<p><b>Important:</b> On any error code, you should print the error to the screen
using <code>fprintf()</code> , and send the error message to <code>stderr</code> (standard
error) and not <code>stdout</code> (standard output). This is accomplished in your C
code as follows:
<p>
<code>fprintf(stderr, &ldquo;whatever the error message is\n&rdquo;);</code> 
</p> 
<p> Your grade will primarily depend only on the correctness of your
  program.  However, programs that run
  signficantly slower than others (i.e., an order of magnitude slower)
  will be penalized.
</p>


<h2>History and an Optional Performance Contest</h2> 

<p>This sorting assignment derives from a yearly competition to make the
fastest disk-to-disk sort in the world. See <a href=http://sortbenchmark.org/>
the sort home page</a> for details. If you look closely, you will see that your
professor was once -- yes, wait for it -- <b>the fastest sorter in the world.</b> </p> 

<p>To continue in this tradition, we will also be holding a <b>sorting
competition.</b>  The variable-sized record sort that you need to
implement for this assignment is a little trickier than the
straight-forward sort, since you need to handle more than just
  100-byte records.
For the contest, we will average together your program's runtime on
three input sets:
<ul>
<li> 1,000,000 input keys: all small records, all less than 8
  integers of data (32 bytes).
<li> 1,000,000 input keys: small and medium-sized records, all less
  than 128 integers of data (512 bytes).  
<li> 1,000,000 input keys: small, medium, and large records, all less than 2048 integers of data (8 KB).
</ul>

<p>Whoever wins the performance contest will win a soft-cover copy of
  the OSTEP text book. </p>

<p> Read more about sorting, including perhaps the
<a href=http://pages.cs.wisc.edu/~remzi/Postscript/nowSort.pdf>NOW-Sort
paper</a> , for some hints on how to make a sort run really fast. Or just use your
common sense! Hint: you'll have to think a bit about hardware
caches.</p> 

<p> We will only measure the performance of assignments that
  sort correctly for all cases!  
</p>

<h2>General Advice</h2> 

<p><b>Start small, and get things working incrementally.</b> For example, first
get a program that simply reads in the input file, one line at a time, and
prints out what it reads in. Then, slowly add features and test them as you
go.  Don't worry about performance until you have all of the
  functionality working correctly.</p> 

<p><b>Testing is critical.</b> Testing your code to make sure it works
is crucial. Write tests to see if your code handles all the cases you
think it should. Be as comprehensive as you can be. Of course, when
grading your projects, we will be. Thus, it is better if you find your
bugs first, before we do.</p>

<p><b>Keep old versions around.</b> Keep copies of older versions of your program
around, as you may introduce bugs and not be able to easily undo them. A
simple way to do this is to keep copies around, by explicitly making copies of
the file at various points during development. For example, let's say you get
a simple version of <code>varsort.c</code> working (say, that just reads in the
file); type <code>cp varsort.c varsort.v1.c</code> to make a copy into the file
<code>varsort.v1.c</code> . More sophisticated developers use version control
systems like CVS (old days) or mercurial or github (modern times), but we'll
not get into that here (though you can, and perhaps should!).</p> 

</td> </tr> </table> </center> </body> </html> 
